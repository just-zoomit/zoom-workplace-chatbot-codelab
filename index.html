
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build a Zoom Workplace Chatbot</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="zoom-workplace-codelab"
                  title="Build a Zoom Workplace Chatbot"
                  environment="web"
                  feedback-link="https://github.com/just-zoomit">
    
      <google-codelab-step label="Before you begin" duration="1">
        <p>In this guide, you&#39;ll learn how to build Zoom Chatbot with node.js experss backend and Javascript.</p>
<p class="image-container"><img alt="alt-text-here" src="img/c90d5b78511d4104.png"></p>
<p>The completed application offers userful features that demonstracte how to create applications for Zoom Team Chat.These features include the following:</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Name</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Setup, Auth, and Deep Linking</strong></p>
</td><td colspan="1" rowspan="1"><p>Set up your first Zoom Chatbot and implement OAuth 2.0 to handle chatbot installation and deep linking.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Send, edit, and delete messages</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to send messages using the Zoom Chatbot API. You&#39;ll create a Python script that authenticates and sends messages to a Zoom channel.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Handling Events</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to handle real-time events in Zoom Chatbot development. We&#39;ll subscribe to Zoom webhook events and use Flask to capture and respond to messages and user actions.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Slash Commands</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to create and handle custom slash commands in Zoom Workplace. You&#39;ll set up commands, process user input, and respond dynamically with chatbot messages.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Markdown Messages &amp; Emojis</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to format and enhance your chatbot responses using markdown syntax, emojis, and message updates that react to user interactions.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Reaction Handling</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to capture and respond to reactions (emoji responses) to messages in Zoom Team Chat. You&#39;ll detect reactions through webhooks and handle them in your server logic.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Replying to Messages (Using Threads)</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to reply to specific Zoom Team Chat messages using threaded replies. This tutorial shows how to nest responses under a parent message using the<code>reply_to</code>parameter in Node.js or Python.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Apps in Chat</strong></p>
</td><td colspan="1" rowspan="1"><p>Learn how to add a Chatbot to a Team Chat channel. This tutorial shows how to detect Chatbot events and responses.</p>
</td></tr>
</table>
<h2 is-upgraded>Prerequisites</h2>
<ol type="1">
<li>A <a href="https://developers.zoom.us" target="_blank">Zoom Developer Account</a></li>
<li>A <strong>General App</strong> created in the <a href="https://marketplace.zoom.us/" target="_blank">Zoom App Marketplace</a></li>
<li>Node.js (v18+ recommended)</li>
<li><a href="https://ngrok.com" target="_blank">ngrok</a> (or another tunneling service)</li>
<li>Your Zoom Chatbot credentials: <ul>
<li><strong>Client ID</strong></li>
<li><strong>Client Secret</strong></li>
<li><strong>Bot JID</strong></li>
<li><strong>Verification Token</strong></li>
</ul>
</li>
</ol>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<p>By the end of this series, you&#39;ll have a working chatbot that can:</p>
<ul>
<li>Post and reply to messages within Zoom Team Chat</li>
<li>Handle events from users and channels</li>
<li>Respond to slash commands</li>
<li>Send interactive messages, markdown, and emojis</li>
<li>Search messages using the Zoom Team Chat API</li>
<li>Schedule messages for future delivery</li>
<li>Integrate with external APIs or databases</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>Git</li>
<li>Node</li>
<li>Ngrok or a tunnel service provider of your choice</li>
<li>Development envrinoment with a code editor and terminal</li>
<li>Zoom Account with developer permissions</li>
</ul>
<h2 is-upgraded>Resources</h2>
<ul>
<li><a href="https://developers.zoom.us/docs/team-chat/" target="_blank">Team Chat</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Compare Zoom Team Chat and Chatbot APIs" duration="0">
        <p>Zoom offers two powerful ways to extend Zoom Team Chat functionality: <strong>Team Chat APIs</strong> and <strong>Chatbot APIs</strong>. While both interact with Zoom Team Chat, they use different authentication methods and serve distinct use cases.</p>
<p>In this section, you&#39;ll implement authentication and authorization flows for both approaches.</p>
<p>To send messages using the <strong>Team Chat APIs</strong>, you&#39;ll implement OAuth 2.0. This allows you to request an account-level or user-level access token and call a wide range of API endpoints beyond Chatbot functionality. When the token expires, you can can use the <a href="https://developers.zoom.us/docs/integrations/oauth/#refresh-an-access-token" target="_blank">refresh token</a> to automatically refresh the access token.</p>
<p>To interact with Zoom Team Chat using a <strong>Chatbot</strong>, you&#39;ll use a Chatbot access token. This token is short-lived (one hour) and does not require a refresh token, making it ideal for lightweight, event-driven applications. When the token expires, you can request a new one without a refresh flow.</p>
<p>Chatbots are effective for keeping teams informed‚Äîwhether by posting reminders, surfacing action items, or responding to slash commands.</p>
<p>Before you begin implementation, review the table below for a comparison of each method&#39;s use cases and capabilities:</p>
<h2 is-upgraded>üîç <strong>Zoom Team Chat APIs vs. Zoom Chatbot APIs</strong></h2>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Category</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Zoom Team Chat APIs</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Zoom Chatbot APIs</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>API Type</strong></p>
</td><td colspan="1" rowspan="1"><p>REST API (part of Zoom&#39;s broader API platform)</p>
</td><td colspan="1" rowspan="1"><p>Specialized API for building Zoom Team Chat bots</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Access Token Type</strong></p>
</td><td colspan="1" rowspan="1"><p>OAuth 2.0 access token (with <strong>refresh token</strong>)</p>
</td><td colspan="1" rowspan="1"><p><strong>Chatbot access token</strong> (no refresh token; short-lived)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Token Expiry</strong></p>
</td><td colspan="1" rowspan="1"><p>Access token expires in 1 hour; refresh token used to renew</p>
</td><td colspan="1" rowspan="1"><p>Expires in 1 hour; must <strong>request a new token manually</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Best For</strong></p>
</td><td colspan="1" rowspan="1"><p>Backend integrations, user-level or account-level operations</p>
</td><td colspan="1" rowspan="1"><p>Real-time bot interactions in Zoom Team Chat</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Installation</strong></p>
</td><td colspan="1" rowspan="1"><p>OAuth flow required (user or admin consent)</p>
</td><td colspan="1" rowspan="1"><p>Installed via Zoom Marketplace as a Chatbot</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Bot Mention Trigger</strong></p>
</td><td colspan="1" rowspan="1"><p>Not supported</p>
</td><td colspan="1" rowspan="1"><p>Yes ‚Äì Bots can listen and respond when @mentioned</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Can Post to Channel</strong></p>
</td><td colspan="1" rowspan="1"><p>Yes, using user token</p>
</td><td colspan="1" rowspan="1"><p>Yes, using bot JID and Chatbot token</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong>Can Read Messages</strong></p>
</td><td colspan="1" rowspan="1"><p>Yes, with appropriate scopes</p>
</td><td colspan="1" rowspan="1"><p>Only if the message is addressed to or from the bot</p>
</td></tr>
</table>
<p> ---- </p>
<h2 is-upgraded>üß© Typical Use Cases: Zoom Team Chat API vs. Zoom Chatbot API</h2>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Use Case</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Zoom Team Chat API</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Zoom Chatbot API</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Send messages to a chat/channel</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes (on behalf of user or system)</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes (as the bot)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Respond to @mentions in chat</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Handle slash commands</p>
</td><td colspan="1" rowspan="1"><p>‚ùå Not supported</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Post interactive message elements (buttons, menus)</p>
</td><td colspan="1" rowspan="1"><p>‚ùå Not supported</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Read chat messages</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes (with scopes)</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Only if sent to/from bot</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Manage channels (create, invite, remove users)</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td><td colspan="1" rowspan="1"><p>‚ùå Not supported</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Receive event notifications (webhooks)</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Via Zoom Event Subscriptions</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Via Chatbot Event Triggers</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>File sharing in chat</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>System-level task notifications</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td><td colspan="1" rowspan="1"><p>‚úÖ Yes</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Set up your development environment" duration="2">
        <p>This guide provides the app&#39;s starter codebase. You can clone that repo and follow the steps to get started:</p>
<h2 is-upgraded>Starter Application</h2>
<pre><code>https://github.com/just-zoomit/zoomworkplace-chatbot -- starter-app

</code></pre>
<h2 is-upgraded>Create and configure Marketplace App</h2>
<h2 is-upgraded>1. Create an OAuth app</h2>
<p>üëâ <a href="https://marketplace.zoom.us/develop/create" target="_blank"><strong>Click here to create an app on the Zoom App Marketplace</strong></a></p>
<ul>
<li>Select <strong>General app</strong> and click <strong>Create</strong>.</li>
</ul>
<p>[!NOTE] Take note of your app ID in the URL after app creation ‚Äì you will need it to later on.</p>
<h2 is-upgraded>2. Retrieve app credentials</h2>
<ul>
<li>Click <strong>Manage</strong> &gt; your app</li>
<li>Navigate to <strong>Basic Information</strong> &gt; <strong>App Credentials</strong></li>
</ul>
<p>[!Note] Use these credentials for <a href="https://developers.zoom.us/docs/integrations/oauth/" target="_blank">authorization</a>.</p>
<h2 is-upgraded>3. Add required scopes</h2>
<p>On the Scope page, select the following:</p>
<ul>
<li>Create apps: marketplace:write:app</li>
<li>View an app: marketplace:read:app</li>
</ul>
<h2 is-upgraded>4. Update the app using the Manifest API</h2>
<p>Use the following endpoint to quickly configure a Zoom Marketplace app:</p>
<p><strong>Example request:</strong></p>
<pre><code>PUT /marketplace/apps/{appId}/manifest
</code></pre>
<p>üëâ <a href="https://developers.zoom.us/docs/api/marketplace/#tag/manifest/put/marketplace/apps/%7BappId%7D/manifest" target="_blank">Update an app by manifest API endpoint</a></p>
<h2 is-upgraded>5. Use Manifest JSON object to create Zoom App</h2>
<p>Use an API tool like Postman to send a PUT request to the manifest endpoint with the JSON object below as the request body.</p>
<p>[!NOTE] Replace placeholder URLs like <code>https://example.ngrok.io</code> with your actual tunnel URL (e.g., from ngrok).</p>
<h2 is-upgraded>App Manifest JSON object - (Request body)</h2>
<pre><code language="language-json" class="language-json">{
    &#34;manifest&#34;: {
        &#34;display_information&#34;: {
            &#34;display_name&#34;: &#34;Zoom Claude Chatbot Sample&#34;
        },
        &#34;oauth_information&#34;: {
            &#34;usage&#34;: &#34;USER_OPERATION&#34;,
            &#34;development_redirect_uri&#34;: &#34;https://example.ngrok.app&#34;,
            &#34;production_redirect_uri&#34;: &#34;&#34;,
            &#34;oauth_allow_list&#34;: [
                &#34;https://example.ngrok.app&#34;,
                &#34;https://oauth.pstmn.io/v1/callback&#34;
            ],
            &#34;strict_mode&#34;: false,
            &#34;subdomain_strict_mode&#34;: false,
            &#34;scopes&#34;: [
                {
                    &#34;scope&#34;: &#34;imchat:userapp&#34;,
                    &#34;optional&#34;: false
                },
                {
                    &#34;scope&#34;: &#34;marketplace:read:app&#34;,
                    &#34;optional&#34;: false
                },
                {
                    &#34;scope&#34;: &#34;marketplace:write:app&#34;,
                    &#34;optional&#34;: false
                }
            ]
        },
        &#34;features&#34;: {
            &#34;products&#34;: [
                &#34;ZOOM_CHAT&#34;
            ],
            &#34;development_home_uri&#34;: &#34;&#34;,
            &#34;production_home_uri&#34;: &#34;&#34;,
            &#34;in_client_feature&#34;: {
                &#34;zoom_app_api&#34;: {
                    &#34;enable&#34;: false,
                    &#34;zoom_app_apis&#34;: []
                },
                &#34;guest_mode&#34;: {
                    &#34;enable&#34;: false,
                    &#34;enable_test_guest_mode&#34;: false
                },
                &#34;in_client_oauth&#34;: {
                    &#34;enable&#34;: false
                },
                &#34;collaborate_mode&#34;: {
                    &#34;enable&#34;: false,
                    &#34;enable_screen_sharing&#34;: false,
                    &#34;enable_play_together&#34;: false,
                    &#34;enable_start_immediately&#34;: false,
                    &#34;enable_join_immediately&#34;: false
                }
            },
            &#34;zoom_client_support&#34;: {
                &#34;mobile&#34;: {
                    &#34;enable&#34;: false
                },
                &#34;zoom_room&#34;: {
                    &#34;enable&#34;: false,
                    &#34;enable_personal_zoom_room&#34;: false,
                    &#34;enable_shared_zoom_room&#34;: false,
                    &#34;enable_digital_signage&#34;: false,
                    &#34;enable_zoom_rooms_controller&#34;: false
                },
                &#34;pwa_client&#34;: {
                    &#34;enable&#34;: false
                }
            },
            &#34;embed&#34;: {
                &#34;meeting_sdk&#34;: {
                    &#34;enable&#34;: false,
                    &#34;enable_device&#34;: false,
                    &#34;devices&#34;: []
                },
                &#34;contact_center_sdk&#34;: {
                    &#34;enable&#34;: false
                },
                &#34;phone_sdk&#34;: {
                    &#34;enable&#34;: false
                }
            },
            &#34;team_chat_subscription&#34;: {
                &#34;enable&#34;: true,
                &#34;enable_support_channel&#34;: false,
                &#34;slash_command&#34;: {
                    &#34;command&#34;: &#34;&#34;,
                    &#34;command_hints&#34;: [],
                    &#34;enable_add_to_channel&#34;: false,
                    &#34;development_message_url&#34;: &#34;https://example.ngrok.app/anthropic&#34;,
                    &#34;production_message_url&#34;: &#34;&#34;,
                    &#34;sender_type&#34;: &#34;zoom&#34;,
                    &#34;welcome_msg&#34;: {
                        &#34;title&#34;: &#34;&#34;,
                        &#34;body&#34;: &#34;&#34;
                    },
                    &#34;trust_domain_list&#34;: []
                },
                &#34;shortcuts&#34;: []
            },
            &#34;event_subscription&#34;: {
                &#34;enable&#34;: false,
                &#34;events&#34;: []
            }
        }
    }
}
</code></pre>
<h2 is-upgraded>Set up credentials</h2>
<p>After configuring your Zoom Marketplace app, add the required values to your environment variables:</p>
<ul>
<li>Navigate to <strong>Basic Information</strong> to get your <code>Client Id</code> and <code>Client Secret</code>.</li>
<li>Ensure the app is marked as <em>User-managed</em> under <strong>Basic Information</strong>.</li>
<li>Go to <strong>Features ‚Üí Access</strong> to find your <code>Secret Token</code>.</li>
<li>Go to <strong>Surface ‚Üí Team Chat Subscription</strong> to find your <code>Bot JID</code></li>
</ul>
<p>Update the following variables in your <code>.env</code> file:</p>
<pre><code language="language-bash" class="language-bash"># Zoom app credentials
ZOOM_CLIENT_ID=your_zoom_client_id
ZOOM_CLIENT_SECRET=your_zoom_client_secret
ZOOM_CHANNEL_ID=your_zoom_channel_id

# Zoom account ID
ACCOUNT_ID=your_account_id

# MongoDB configuration
MONGO_URI=your_mongodb_connection_string

# Zoom bot JIDs (from Marketplace app settings)
ZOOM_ROBOT_JID=your_zoom_robot_jid
ZOOM_USER_JID=your_zoom_user_jid

# Server configuration (optional)
PORT=3000
</code></pre>
<p>:warning: <strong>Do not store credentials in plain text in production environments</strong></p>


      </google-codelab-step>
    
      <google-codelab-step label="Review the starter codebase" duration="0">
        <p>In this section, you&#39;ll review a few areas of the app&#39;s starter codebase to which you&#39;ll add functionality in this codelab.</p>
<h2 is-upgraded>Folder and file structure</h2>
<p>The following table contains an overview of the folder and file structure of the app:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Path</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>server.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Main entry point for the Express application. Loads environment variables, configures middleware (CORS, JSON), mounts all routes, and starts the HTTP server.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>routes/webhookRoutes.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Handles incoming Zoom webhook events such as messages, reactions, and slash commands. Verifies the webhook signature or token before processing.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>routes/oauthRoutes.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Demonstrates how to handle OAuth flows or token exchanges for installing and authorizing the Zoom Chatbot or app.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>routes/messageRoutes.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Provides endpoints that send or reply to Zoom Team Chat messages, exposing a simple REST API layer for the frontend or Postman.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>utils/anthropic.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Integrates with the Anthropic API (Claude). Manages non-streaming and streaming AI responses, conversation history, and message parsing.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>utils/validation.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Centralized input validation logic for incoming requests. Ensures required parameters (like <code>to_jid</code>, <code>message</code>) are present and correctly formatted.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>utils/zoom-chatbot-Auth.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Handles Zoom Chatbot authentication and token generation. Caches and refreshes tokens securely using either Chatbot or Server-to-Server OAuth.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>utils/zoom-Api.js</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Contains helper functions for interacting with Zoom APIs‚Äîsending, editing, deleting, or searching Team Chat messages. Encapsulates retry and error handling.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>views/index.html</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Public landing page for the tutorial or demo application. Often includes a button to authenticate or deep-link into the Zoom client.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>views/dashboard.html</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Secondary landing page reached after authentication or installation. Provides deep-link buttons or dashboards that connect back into the Zoom Chatbot.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>.env</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Stores environment variables such as Zoom credentials, Anthropic keys, model names, and app configuration. Never commit this file to version control.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>package.json</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Declares Node.js dependencies, scripts, and metadata for the project. Used by npm or yarn to install and run the application.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>README.md</code></strong></p>
</td><td colspan="1" rowspan="1"><p>Primary documentation for the tutorial. Explains setup, environment configuration, and the learning objectives of each section.</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Authenticate with Zoom Team Chat" duration="0">
        <p>To interact with the Zoom Team Chat API, all requests must be authorized using OAuth 2.0. Each API request must include a <code>Bearer</code> token in the <code>Authorization</code> header. Zoom supports industry-standard OAuth 2.0 (RFC 6749) flows for securely handling access and refresh tokens.</p>
<p>Unlike chatbots, where you <a href="https://developers.zoom.us/docs/team-chat/installation-and-authentication/#request-chatbot-token" target="_blank">request a new token</a> for each interaction, Zoom Team Chat integrations require secure token storage and lifecycle management. Through the OAuth 2.0 flow, the authorization code provided in the redirect URL enables the use of the <code>authorization_code</code> grant type to access additional Zoom API endpoints.</p>
<p>Your app must be able to:</p>
<ul>
<li>Request, refresh, and revoke tokens based on the selected OAuth flow</li>
<li>Securely store tokens</li>
<li>Periodically renew or refresh tokens before expiration</li>
</ul>
<p>In the next section, you&#39;ll extend a chatbot app built with Node.js and Express by implementing endpoints to authenticate users, manage OAuth tokens, and enable deep linking to the Zoom Team Chat chatbot in the Zoom desktop client.</p>
<h2 is-upgraded>Resources</h2>
<ul>
<li><a href="https://developers.zoom.us/docs/team-chat/installation-and-authentication/" target="_blank">Team Chat: Installation and Authorize</a></li>
<li><a href="https://developers.zoom.us/docs/integrations/oauth/" target="_blank">OAuth 2.0</a></li>
<li><a href="https://developers.zoom.us/docs/integrations/end-user-auth/" target="_blank">End user authorization</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Authorize and deep link users" duration="0">
        <p>In this section, you&#39;ll implement the installation and authorization flows to install a chatbot in a Zoom workspace, authenticate API requests, and deep link users between a browser-based application and the Zoom desktop client. This enables seamless transitions from SaaS web apps to native collaboration environments where work happens.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>Secure Zoom Team Chat integration using OAuth 2.0</li>
<li>Seamless deep linking between browser and Zoom client</li>
<li>Reusable server endpoints for message delivery and future features</li>
</ul>
<h2 is-upgraded>Implement OAuth 2.0 authentication</h2>
<p>Add two routes to handle the OAuth 2.0 flow: one to initiate login, and another to process the callback from Zoom.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Endpoint</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>/login</code></p>
</td><td colspan="1" rowspan="1"><p>Redirects users to Zoom&#39;s OAuth consent screen using the app&#39;s client ID and redirect URI.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>/callback</code></p>
</td><td colspan="1" rowspan="1"><p>Handles the redirect from Zoom, validates the <code>state</code> parameter, exchanges the authorization code for an access token, and stores tokens in the session for later use.</p>
</td></tr>
</table>
<p><strong>File path:</strong></p>
<pre><code language="language-bash" class="language-bash">routes/oauth-routes.js
</code></pre>
<pre><code language="language-js" class="language-js">import express from &#39;express&#39;;
import crypto from &#39;crypto&#39;;
import { buildBasicAuth, exchangeCodeForAccessToken } from &#39;../utils/zoom-api.js&#39;;

const router = express.Router();

// Start OAuth flow
router.get(&#39;/login&#39;, (req, res) =&gt; {
  try {
    const state = crypto.randomBytes(16).toString(&#39;hex&#39;);
    req.session.oauth_state = state;

    const url = buildBasicAuth({
      clientId: process.env.ZOOM_CLIENT_ID,
      redirectUri: process.env.ZOOM_REDIRECT_URI,
      state,
    });

    console.log(&#39;Redirecting to Zoom OAuth URL:&#39;, url);
    return res.redirect(url);
  } catch (e) {
    console.error(&#39;OAuth login error:&#39;, e);
    return res.status(500).send(&#39;OAuth not configured.&#39;);
  }
});

// Handle Zoom OAuth callback
router.get(&#39;/callback&#39;, async (req, res) =&gt; {
  try {
    const { code, state, error, error_description } = req.query;

    if (error) {
      console.warn(&#39;Zoom authorization error:&#39;, error, error_description);
      return res.status(400).send(`Authorization error: ${error}`);
    }

    if (!code || !state) return res.status(400).send(&#39;Missing code or state.&#39;);
    if (state !== req.session.oauth_state) return res.status(400).send(&#39;Invalid state.&#39;);
    delete req.session.oauth_state; // One-time use

    const tokens = await exchangeCodeForAccessToken({
      code,
      redirectUri: process.env.ZOOM_REDIRECT_URI,
      clientId: process.env.ZOOM_CLIENT_ID,
      clientSecret: process.env.ZOOM_CLIENT_SECRET,
    });

    // For demonstration only: store tokens in session (use secure storage in production)
    req.session.zoomTokens = tokens;

    // Option A: Redirect to a confirmation page with a button to open in Zoom
    return res.redirect(&#39;/dashboard&#39;);

    // Option B: Redirect directly into Zoom using a JID deep link
    // return res.redirect(`https://zoom.us/launch/chat?jid=${process.env.ROBOT_ZOOM_BOT_JID}`);
  } catch (e) {
    console.error(&#39;OAuth callback error:&#39;, e);
    return res.status(500).send(&#39;Token exchange failed.&#39;);
  }
});

export default router;
</code></pre>
<h2 is-upgraded>Add deep linking to the chatbot</h2>
<p>After the user authorizes your app, use a deep link to open the chatbot directly in Zoom Team Chat. Add the following logic to a button on your confirmation page:</p>
<p><strong>File path:</strong></p>
<pre><code language="language-bash" class="language-bash">views/dashboard.html
</code></pre>
<pre><code language="language-html" class="language-html">&lt;script&gt;
  const chatbotJid = &#34;robot_v1nhrah1hrqhuexexb5nn5-a@xmpp.zoom.us&#34;; // Replace with your bot JID

  document.getElementById(&#34;zoom-button&#34;).addEventListener(&#34;click&#34;, () =&gt; {
    const link = `https://zoom.us/launch/chat?jid=${encodeURIComponent(chatbotJid)}`;
    window.open(link, &#34;_blank&#34;, &#34;noopener,noreferrer&#34;);
  });
&lt;/script&gt;
</code></pre>
<p>Use this pattern to create a smooth transition from your browser-based app to the Zoom client, improving user experience post-authorization.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Send a message to Zoom Team Chat" duration="0">
        <p>In this section, you&#39;ll implement a utility function that sends messages from your chatbot to Zoom Team Chat using the Chatbot API. This function constructs a message body, retrieves a chatbot access token, and sends a <code>POST</code> request to Zoom&#39;s <code>/im/chat/messages</code> endpoint.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A reusable function to send messages to Zoom Team Chat</li>
<li>Support for replying to messages using message threading</li>
<li>Console logging for debugging message payloads and errors</li>
</ul>
<h2 is-upgraded>Implement message sending logic</h2>
<p>Create a utility function to send a chat message using the Chatbot API. The function accepts the recipient JID, message content, and an optional message ID for threaded replies.</p>
<h3 is-upgraded>File Path</h3>
<pre><code>utils/zoom-api.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code>/**
 * Send a message to Zoom Team Chat
 * @param {string} toJid - Recipient JID (user or channel)
 * @param {string} message - Message content
 * @param {string} [replyTo] - Optional message ID to reply to
 * @returns {Promise&lt;Object&gt;} API response
 */
export async function sendChatMessage(toJid, message, replyTo = null) {
  try {
    
    const accessToken = await getChatbotToken();
    
    const body = {
      account_id: &#34;YOUR_ACCOUNT_ID&#34;,
      &#34;content&#34;: {
          &#34;head&#34;: {
           &#34;text&#34;: &#34;Hello World&#34;
          },
          &#34;body&#34;: [
           {
            &#34;type&#34;: &#34;message&#34;,
            &#34;text&#34;: message
           }
          ]
         },
      robot_jid: &#34;YOUR_ROBOT_JID&#34;,
      to_jid: &#39;YOUR_JID&#39;,
      user_jid: &#34;YOUR_USER_JID&#34;,
      
    };

    console.log(&#39;Preparing to send message to Zoom Team Chat:&#39;, body);

    if (replyTo) {
      body.reply_to = replyTo;
    }

    const response = await fetch(`${ZOOM_API_BASE_URL}/im/chat/messages`, {
      method: &#39;POST&#39;,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        &#39;Content-Type&#39;: &#39;application/json&#39;,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Failed to send message: ${error.message || response.statusText}`);
    }

    return response.json();
  } catch (error) {
    console.error(&#39;Error sending chat message:&#39;, error);
    throw error;
  }
}

</code></pre>
<p>This utility function enables structured messaging and optional threading in Zoom Team Chat‚Äîessential features for building interactive, event-driven chatbot experiences.</p>
<h2 is-upgraded>Create message route handler</h2>
<p>Create a Post route to handler for messages.</p>
<h3 is-upgraded>File Path</h3>
<pre><code language="language-bash" class="language-bash">routes/message-routes.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code language="language-js" class="language-js">import express from &#39;express&#39;;
import fetch from &#39;node-fetch&#39;;
import { getChatbotToken } from &#39;../utils/zoom-chatbot-auth.js&#39;;
import { validateMessagePayload, createValidationMiddleware, sanitizeMessage } from &#39;../utils/validation.js&#39;;

const router = express.Router();

/**
* POST /api/message
* Sends a message to a Zoom Team Chat channel or user.
* Optional: include `reply_to` for threaded replies.
*/
router.post(&#39;/message&#39;, createValidationMiddleware(validateMessagePayload), async (req, res) =&gt; {
 try {
   const { to_jid, message, reply_to } = req.body;

   // Sanitize message content
   const sanitizedMessage = sanitizeMessage(message);

   // Retrieve OAuth token from helper (Server-to-Server)
   const accessToken = await getChatbotToken();

   // Construct request body for Zoom API
   const body = {
     to_jid,
     message: sanitizedMessage,
   };

   // Optional: add reply_to to nest the message in a thread
   if (reply_to) body.reply_to = reply_to;

   const response = await fetch(&#39;https://api.zoom.us/v2/im/chat/messages&#39;, {
     method: &#39;POST&#39;,
     headers: {
       Authorization: `Bearer ${accessToken}`,
       &#39;Content-Type&#39;: &#39;application/json&#39;,
     },
     body: JSON.stringify(body),
   });

   const data = await response.json();

   if (!response.ok) {
     console.error(&#39;Zoom API error:&#39;, data);
     return res.status(response.status).json({
       success: false,
       error: &#39;Zoom API error&#39;,
       details: data
     });
   }

   console.log(&#39;Message sent successfully:&#39;, data);
   return res.status(200).json({
     success: true,
     message: &#39;Message sent successfully!&#39;,
     data,
   });
 } catch (error) {
   console.error(&#39;Error sending message:&#39;, error);
   res.status(500).json({ 
     success: false,
     error: &#39;Internal server error&#39;,
     message: process.env.NODE_ENV === &#39;production&#39; ? &#39;Something went wrong&#39; : error.message
   });
 }
});

export default router;

</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Handle Zoom Team Chatbot events" duration="0">
        <p>In this section, you&#39;ll implement a webhook handler to process real-time events sent from Zoom Team Chat to your chatbot. These events include bot installation, message notifications, and app deauthorization. You&#39;ll also handle Zoom&#39;s URL validation flow to verify your webhook endpoint.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A secure webhook handler for Zoom Team Chat events</li>
<li>Support for responding to bot messages and system events</li>
<li>Built-in validation and health check for endpoint reliability</li>
</ul>
<h2 is-upgraded>Implement a webhook event handler</h2>
<p>Set up a route to handle incoming Zoom Team Chatbot events, validate requests, and process supported event types.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Event type</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>bot_notification</code></p>
</td><td colspan="1" rowspan="1"><p>Triggered when a user sends a message to the chatbot</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>bot_installed</code></p>
</td><td colspan="1" rowspan="1"><p>Sent when the chatbot is installed in a Zoom Team Chat workspace</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>app_deauthorized</code></p>
</td><td colspan="1" rowspan="1"><p>Sent when the app is uninstalled</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>endpoint.url_validation</code></p>
</td><td colspan="1" rowspan="1"><p>Used by Zoom to validate and verify the webhook endpoint</p>
</td></tr>
</table>
<h3 is-upgraded>File Path</h3>
<pre><code language="language-bash" class="language-bash">routes/zoom-webhookHandler.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code language="language-js" class="language-js">import express from &#39;express&#39;;
import { callAnthropicAPI } from &#39;../utils/anthropic.js&#39;;
import { validateWebhookPayload, createValidationMiddleware } from &#39;../utils/validation.js&#39;;

const router = express.Router();

/**
 * Handles Zoom Team Chat webhook events
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 */
async function handleZoomWebhook(req, res) {
  try {
    const { event, payload } = req.body;
    
    console.log(`Received Zoom webhook event: ${event}`);
    console.log(&#39;Payload:&#39;, payload);

    const toJid = payload?.toJid;
    const message = payload?.cmd || payload?.message || &#39;&#39;;
   

    switch (event) {
      case &#39;bot_notification&#39;:
        console.log(&#39;Processing bot notification from Zoom Team Chat&#39;);
        sendChatMessage(toJid, message)
        break;

      case &#39;bot_installed&#39;:
        console.log(&#39;Zoom Team Chat bot installed successfully&#39;);
        break;

      case &#39;app_deauthorized&#39;:
        console.log(&#39;Zoom Team Chat bot uninstalled&#39;);
        break;

      case &#39;endpoint.url_validation&#39;:
        console.log(&#39;Validating webhook endpoint URL&#39;);
        return res.status(200).json({
          message: {
            plainToken: payload?.plainToken || &#39;missing_token&#39;,
          },
        });

      default:
        console.log(`Unsupported Zoom webhook event type: ${event}`);
        break;
    }

    res.status(200).json({ 
      success: true, 
      message: &#39;Event processed successfully&#39;,
      event 
    });

  } catch (error) {
    console.error(&#39;Error handling Zoom webhook event:&#39;, error);
    
    res.status(500).json({ 
      success: false, 
      error: &#39;Internal Server Error&#39;,
      message: error.message 
    });
  }
}

// Webhook route with validation
router.post(&#39;/&#39;, createValidationMiddleware(validateWebhookPayload), handleZoomWebhook);

// Health check endpoint
router.get(&#39;/health&#39;, (_req, res) =&gt; {
  res.status(200).json({ 
    status: &#39;healthy&#39;, 
    timestamp: new Date().toISOString(),
    service: &#39;zoom-webhook-handler&#39;
  });
});

export default router;
</code></pre>
<p>This webhook handler enables real-time communication between your Zoom chatbot and users, allowing your app to respond to messages, handle installations, and maintain a reliable connection with Zoom Team Chat.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Add slash commands and UI elements" duration="0">
        <p>In this section, you&#39;ll configure a slash command in the Zoom App Marketplace and use the App Card Builder Kit to design interactive UI elements. These enhancements allow users to trigger your chatbot using a command and receive structured messages with buttons for feedback or interaction.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A slash command configured to invoke your chatbot in Zoom Team Chat</li>
<li>An interactive message layout created using the App Card Builder Kit</li>
<li>An updated <code>sendChatMessage</code> function that sends a UI-rich response</li>
</ul>
<h2 is-upgraded>Configure a slash command</h2>
<p>Set up a slash command to allow users to trigger the chatbot from Zoom Team Chat.</p>
<ol type="1">
<li>Navigate to the <strong>Zoom App Marketplace</strong></li>
<li>Select your app</li>
<li>In the sidebar, go to <strong>Surface</strong> &gt; <strong>Team Chat Subscription</strong></li>
<li>Toggle <strong>Slash Command</strong> and enter <code>zwc</code> (or a command of your choice)</li>
</ol>
<p><strong>Example:</strong></p>
<p class="image-container"><img alt="Zoom App Marketplace Slash Command Setup" src="img/a01610bc395b0921.png"></p>
<h2 is-upgraded>Create UI elements with Card Builder</h2>
<p>Use the <a href="https://developers.zoom.us/docs/workplace/chat/cards/card-builder/" target="_blank">Zoom App Card Builder Kit</a> to design structured messages and interactive components like buttons.</p>
<ol type="1">
<li>Open the <strong>App Card Builder Kit</strong></li>
<li>In the <strong>Actions</strong> panel, select <strong>Feedback Buttons</strong></li>
<li>Customize the card layout and preview the message</li>
<li>Copy the generated JSON and update your chatbot message payload</li>
</ol>
<p><strong>Example:</strong></p>
<p class="image-container"><img alt="App Card Builder UI Elements" src="img/a86a60f206ab59b0.png"></p>
<h2 is-upgraded>Update chatbot message payload</h2>
<p>To include UI elements like feedback buttons in your chatbot response, update the <code>body</code> object in your <code>sendChatMessage</code> function.</p>
<p><strong>File path:</strong></p>
<pre><code language="language-bash" class="language-bash">utils/zoom-api.js
</code></pre>
<pre><code language="language-js" class="language-js">const body = {
  account_id: &#34;YOUR_ACCOUNT_ID&#34;,
  robot_jid: &#34;YOUR_ROBOT_JID&#34;,
  to_jid: &#34;YOUR_JID&#34;,
  user_jid: &#34;YOUR_USER_ID&#34;,
  content: {
    head: {
      text: &#34;Hello World&#34;,
      style: { bold: true }
    },
    body: [
      {
        type: &#34;message&#34;,
        text: message
      },
      {
        type: &#34;actions&#34;,
        items: [
          {
            text: &#34;Thumbsup&#34;,
            value: &#34;thumbsup&#34;,
            style: &#34;Thumbsup&#34;
          },
          {
            text: &#34;Thumbsdown&#34;,
            value: &#34;thumbsdown&#34;,
            style: &#34;Thumbsdown&#34;
          }
        ]
      }
    ]
  }
};
</code></pre>
<p>This pattern combines slash commands and interactive cards to create a more engaging Zoom Team Chat experience‚Äîmaking your chatbot feel intuitive, responsive, and visually aligned with modern collaboration workflows.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Handle reactions from interactive messages" duration="0">
        <p>In this section, you&#39;ll add logic to handle button clicks from interactive messages sent by your Zoom Team Chatbot. When a user clicks a button‚Äîsuch as a thumbs-up or thumbs-down‚Äîyour bot will capture the value and respond accordingly in chat.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>Support for handling interactive message button clicks</li>
<li>Dynamic chatbot responses based on user input</li>
<li>A visual confirmation of the button value in Zoom Team Chat</li>
</ul>
<h2 is-upgraded>Add a handler for interactive message actions</h2>
<p>Extend your webhook event handler to respond to the <code>interactive_message_actions</code> event. This allows your bot to capture the value of a clicked button and send a follow-up message to the chat.</p>
<p><strong>File path: </strong><code>routes/zoom-webhookHandler.js</code></p>
<pre><code language="language-js" class="language-js">case &#39;interactive_message_actions&#39;:
  console.log(&#39;Processing interactive message action from Zoom Team Chat&#39;);
  sendChatMessage(toJid, `You clicked a button with value: ${payload?.actionItem?.value || &#39;unknown&#39;}`);
  break;
</code></pre>
<h2 is-upgraded>Test your chatbot&#39;s reaction handling</h2>
<ol type="1">
<li>Launch your chatbot in Zoom Team Chat</li>
<li>Click the thumbs-up or thumbs-down button</li>
<li>The chatbot should reply with the value of the button you clicked</li>
</ol>
<p><strong>Example:</strong></p>
<p class="image-container"><img alt="Reaction handling in Zoom Team Chat" src="img/bb7d20b229ea6492.png"></p>
<p>This interaction pattern gives users immediate feedback and enables lightweight input collection inside Zoom Team Chat‚Äîideal for surveys, approvals, or quick actions.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Reply to messages with Anthropic API (using threads)" duration="0">
        <p>In this section, you&#39;ll integrate the Anthropic API with your Zoom Team Chatbot to handle user messages in threads. When a user sends a message to the bot, your app will generate a reply using an AI model (such as Claude 3.5) and respond in the same thread.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A working integration with the Anthropic API</li>
<li>Threaded AI responses in Zoom Team Chat</li>
<li>Session-based message history for improved conversational context</li>
</ul>
<h2 is-upgraded>Add Anthropic integration</h2>
<p>Create a utility function that sends a user&#39;s message to Anthropic, receives a completion, and replies to the chat thread. It maintains per-user history to support contextual conversations.</p>
<pre><code>utils/anthropic.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code>// anthropic.js
import dotenv from &#39;dotenv&#39;;
import { sendChatMessage } from &#39;./zoom-api.js&#39;;

dotenv.config();

let conversationHistory = new Map();

const ANTHROPIC_URL = &#39;https://api.anthropic.com/v1/messages&#39;;
// ‚ö†Ô∏è Use a model your key actually has access to. Consider resolving via /v1/models at boot.
const DEFAULT_MODEL = process.env.ANTHROPIC_MODEL || &#39;claude-3-5-sonnet-latest&#39;;

function buildHeaders() {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) throw new Error(&#39;Missing ANTHROPIC_API_KEY in environment variables.&#39;);
  if (!apiKey.startsWith(&#39;sk-ant-&#39;)) throw new Error(&#39;Invalid ANTHROPIC_API_KEY format. Should start with &#34;sk-ant-&#34;.&#39;);

  return {
    &#39;x-api-key&#39;: apiKey,
    &#39;anthropic-version&#39;: &#39;2023-06-01&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;,
  };
}

function buildRequestBody({ model, messages, stream }) {
  return {
    model,
    max_tokens: 1000,
    temperature: 0.7,
    system:
      &#39;You are a helpful AI assistant integrated with Zoom Team Chat. Provide concise, helpful responses to user questions and requests.&#39;,
    messages,
    stream,
  };
}

/**
 * Main entry point.
 * @param {Object} payload - Zoom webhook payload containing toJid / message
 * @param {Object} options - { stream?: boolean, onStreamChunk?: (chunk, soFar) =&gt; void }
 */
export async function callAnthropicAPI(payload, options = {}) {
  const userJid = payload?.toJid;
  if (!userJid) {
    console.error(&#39;Error: payload.toJid is missing.&#39;);
    return;
  }

  const { stream = true, onStreamChunk = null } = options;

  try {
    const headers = buildHeaders();

    // Build conversation
    const history = conversationHistory.get(userJid) || [];
    const userMessage = { role: &#39;user&#39;, content: payload.cmd || payload.message || &#39;Hello&#39; };
    history.push(userMessage);

    const requestData = buildRequestBody({
      model: DEFAULT_MODEL,
      messages: history,
      stream,
    });

    console.log(`Sending message to Anthropic (model=${DEFAULT_MODEL}, stream=${stream}) for user: ${userJid}`);

    const completion = stream
      ? await handleStreamingResponse(requestData, headers, userJid, payload, onStreamChunk)
      : await handleNonStreamingResponse(requestData, headers, userJid, payload);

    return completion;
  } catch (error) {
    console.error(&#39;Error in callAnthropicAPI:&#39;, error?.message || error);

    try {
      await sendChatMessage(
        payload?.toJid,
        &#39;Sorry, I hit an AI model error. I will be back shortly. (Check model access/config.)&#39;,
        payload?.reply_to || null
      );
    } catch (sendError) {
      console.error(&#39;Failed to send error message to user:&#39;, sendError?.message || sendError);
    }

    // Normalize Anthropic error logging
    const status = error?.status ?? error?.response?.status;
    const data = error?.response?.data ?? error?.message;
    if (status) {
      console.error(&#39;Anthropic API Error:&#39;, { status, data });
      if (status === 401) console.error(&#39;Authentication failed. Check ANTHROPIC_API_KEY.&#39;);
      if (status === 429) console.error(&#39;Rate limit exceeded.&#39;);
      if (status === 400) console.error(&#39;Bad request (params/schema).&#39;);
      if (status === 404) console.error(&#39;Model not found for your account/region.&#39;);
    } else if (error?.request) {
      console.error(&#39;No response from Anthropic API:&#39;, error.message);
    }
  }
}

/**
 * Non-streaming path using native fetch.
 */
async function handleNonStreamingResponse(requestData, headers, userJid, payload) {
  const response = await fetch(ANTHROPIC_URL, {
    method: &#39;POST&#39;,
    headers,
    body: JSON.stringify({ ...requestData, stream: false }),
  });

  if (!response.ok) {
    // try to read JSON, fall back to text
    let errorData = {};
    try {
      errorData = await response.json();
    } catch {
      errorData = { message: await response.text() };
    }
    const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
    error.status = response.status;
    error.response = { data: errorData };
    throw error;
  }

  const data = await response.json();

  if (!data?.content || !Array.isArray(data.content)) {
    throw new Error(`Unexpected response from Anthropic API: ${JSON.stringify(data)}`);
  }

  const completion = data.content
    .filter((b) =&gt; b.type === &#39;text&#39;)
    .map((b) =&gt; b.text)
    .join(&#39;\n&#39;)
    .trim();

  if (!completion) throw new Error(&#39;Empty response from Anthropic API&#39;);

  // Append assistant message &amp; trim history
  const history = conversationHistory.get(userJid) || [];
  history.push({ role: &#39;assistant&#39;, content: completion });
  conversationHistory.set(userJid, history.length &gt; 20 ? history.slice(-20) : history);

  await sendChatMessage(userJid, completion, payload.reply_to || null);
  console.log(&#39;Successfully sent response to Zoom Team Chat&#39;);

  return completion;
}

/**
 * Streaming path using native fetch + Web Streams.
 * Parses Server-Sent Events (SSE): frames separated by blank line, with &#34;event:&#34; and &#34;data:&#34; lines.
 */
async function handleStreamingResponse(requestData, headers, userJid, payload, onStreamChunk) {
  // IMPORTANT for SSE:
  const sseHeaders = {
    ...headers,
    Accept: &#39;text/event-stream&#39;,
  };

  const response = await fetch(ANTHROPIC_URL, {
    method: &#39;POST&#39;,
    headers: sseHeaders,
    body: JSON.stringify({ ...requestData, stream: true }),
  });

  if (!response.ok) {
    let errorData = {};
    try {
      errorData = await response.json();
    } catch {
      errorData = { message: await response.text() };
    }
    const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
    error.status = response.status;
    error.response = { data: errorData };
    throw error;
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buf = &#39;&#39;;
  let completion = &#39;&#39;;

  try {
    for (;;) {
      const { done, value } = await reader.read();
      if (done) break;

      buf += decoder.decode(value, { stream: true });

      // SSE frames are separated by a blank line (\n\n)
      let sep;
      while ((sep = buf.indexOf(&#39;\n\n&#39;)) !== -1) {
        const frame = buf.slice(0, sep);
        buf = buf.slice(sep + 2);

        let eventType = &#39;&#39;;
        let dataLine = &#39;&#39;;

        for (const line of frame.split(&#39;\n&#39;)) {
          if (line.startsWith(&#39;event:&#39;)) eventType = line.slice(6).trim();
          else if (line.startsWith(&#39;data:&#39;)) dataLine += line.slice(5).trim();
        }

        if (!dataLine) continue;
        if (dataLine === &#39;[DONE]&#39;) {
          // Some providers use this sentinel; Anthropic also sends message_stop events
          continue;
        }

        try {
          const parsed = JSON.parse(dataLine);

          // Anthropic streaming lifecycle:
          // - content_block_start
          // - content_block_delta (delta.type === &#39;text_delta&#39;, delta.text)
          // - content_block_stop
          // - message_stop
          if (parsed.type === &#39;content_block_delta&#39; &amp;&amp; parsed.delta?.type === &#39;text_delta&#39;) {
            const chunk = parsed.delta.text || &#39;&#39;;
            if (chunk) {
              completion += chunk;
              onStreamChunk?.(chunk, completion);
            }
          }

          if (parsed.type === &#39;message_stop&#39; || eventType === &#39;message_stop&#39;) {
            // End of message
            // Clear buf in case anything remains
            buf = &#39;&#39;;
          }
        } catch {
          // Ignore malformed pieces
        }
      }
    }
  } finally {
    try {
      reader.releaseLock();
    } catch {}
  }

  if (!completion.trim()) {
    throw new Error(&#39;Empty response from Anthropic streaming API&#39;);
  }

  // Append assistant message &amp; trim history
  const history = conversationHistory.get(userJid) || [];
  history.push({ role: &#39;assistant&#39;, content: completion });
  conversationHistory.set(userJid, history.length &gt; 20 ? history.slice(-20) : history);

  // Send the full completion to Zoom (the streaming UI can also show partials via onStreamChunk)
  await sendChatMessage(userJid, completion, payload.reply_to || null);
  console.log(&#39;Successfully sent streaming response to Zoom Team Chat&#39;);

  return completion;
}

export async function callAnthropicAPIStreaming(payload, onStreamChunk) {
  return callAnthropicAPI(payload, {
    stream: true,
    onStreamChunk,
  });
}

export function clearConversationHistory(userJid) {
  conversationHistory.delete(userJid);
  console.log(`Cleared conversation history for user: ${userJid}`);
}

export function getConversationHistory(userJid) {
  return conversationHistory.get(userJid) || [];
}

</code></pre>
<h2 is-upgraded>Update webhook to trigger Anthropic replies</h2>
<p>Modify the bot_notification case in your webhook handler to call the Anthropic API when a user sends a message to the chatbot.</p>
<pre><code>routes/zoom-webhookHandler.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code>import { callAnthropicAPI } from &#39;../utils/anthropic.js&#39;;

...
  case &#39;bot_notification&#39;:
        console.log(&#39;Processing bot notification from Zoom Team Chat&#39;);
        
        await callAnthropicAPI(payload, true);
        break;
</code></pre>
<p>This implementation allows your Zoom Team Chatbot to respond in threads using AI-generated answers, creating a conversational experience powered by Anthropic&#39;s large language models.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Add app shortcuts and webview" duration="0">
        <p>In this section, you&#39;ll configure an app shortcut in the Zoom App Marketplace and enable a secure webview experience inside Zoom Team Chat. Shortcuts allow users to trigger actions like launching modals or composing messages, while the webview surface enables in-app UI hosted from your server.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A Zoom Team Chat shortcut with a custom command and modal launch</li>
<li>Secure headers added to enable embedded webviews</li>
<li>A working webview rendered inside the Zoom client</li>
</ul>
<h2 is-upgraded>Configure an app shortcut</h2>
<p>Create a new app shortcut that lets users trigger a modal or message action directly from Zoom Team Chat.</p>
<ol type="1">
<li>Go to the <strong>Zoom App Marketplace</strong></li>
<li>Select your app</li>
<li>Navigate to <strong>Surface &gt; App Shortcuts</strong></li>
<li>Toggle <strong>New Action</strong> to enabled</li>
<li>Fill in the fields:<ul>
<li><strong>Action Name</strong>: <code>Create note</code></li>
<li><strong>Action Command ID</strong>: <code>create_note</code></li>
</ul>
</li>
<li>Choose both action types:<ul>
<li>Compose Box</li>
<li>Message Action</li>
</ul>
</li>
<li>(Optional) Set:<ul>
<li><strong>Action Dialog Title</strong>: <code>Create a note</code></li>
<li><strong>Action Dialog Size</strong>: Medium</li>
<li>Upload an icon if desired</li>
</ul>
</li>
</ol>
<p><strong>Example UI:</strong></p>
<p class="image-container"><img alt="Configure App Shortcut ‚Äì Action Setup" src="img/d958e4a7ec478f7.png"><img alt="Configure App Shortcut ‚Äì Dialog Setup" src="img/dd082bae6b8bc384.png"></p>
<h2 is-upgraded>Enable secure webview</h2>
<p>To render a custom web experience inside the Zoom client, configure the <strong>Surface &gt; Home URL</strong> and allowed domains.</p>
<ol type="1">
<li>In the <strong>Surface</strong> tab, scroll to <strong>Home URL</strong></li>
<li>Enter the webview URL served by your backend (e.g. <code>https://example.ngrok.app/webview</code>)</li>
<li>Under <strong>Domain Allow List</strong>, add the root domain (<code>ngrok.app</code>)</li>
<li>Provide a one-line justification (e.g. &#34;Development testing using ngrok&#34;)</li>
</ol>
<p><strong>Example UI:</strong></p>
<p class="image-container"><img alt="Configure Home URL and Domain List" src="img/b50c668021cc1703.png"></p>
<h2 is-upgraded>Add security headers to support webview</h2>
<p>Install <a href="https://www.npmjs.com/package/helmet" target="_blank">Helmet</a> to enforce content security policies that allow Zoom to embed your app in the Zoom client.</p>
<h3 is-upgraded>Install Helmet</h3>
<pre><code language="language-bash" class="language-bash">npm install helmet
</code></pre>
<h3 is-upgraded>File path: <code>server.js</code></h3>
<pre><code language="language-js" class="language-js">import helmet from &#39;helmet&#39;;

app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      defaultSrc: [&#34;&#39;self&#39;&#34;],
      scriptSrc: [
        &#34;&#39;self&#39;&#34;,
        &#34;&#39;unsafe-inline&#39;&#34;,
        &#34;https://appssdk.zoom.us&#34;,
        &#34;https://source.zoom.us&#34;,
        &#34;https://cdn.ngrok.com&#34;
      ],
      styleSrc: [&#34;&#39;self&#39;&#34;, &#34;&#39;unsafe-inline&#39;&#34;, &#34;https://cdn.ngrok.com&#34;],
      fontSrc:  [&#34;&#39;self&#39;&#34;, &#34;data:&#34;, &#34;https://cdn.ngrok.com&#34;],
      imgSrc:   [&#34;&#39;self&#39;&#34;, &#34;data:&#34;, &#34;blob:&#34;],
      connectSrc: [
        &#34;&#39;self&#39;&#34;, &#34;wss:&#34;,
        &#34;https://zoom.us&#34;, &#34;https://*.zoom.us&#34;,
        &#34;https://*.ngrok.app&#34;, &#34;https://*.ngrok.io&#34;
      ],
      frameAncestors: [&#34;&#39;self&#39;&#34;, &#34;https://*.zoom.us&#34;], // Required for Zoom
    },
  },
}));
</code></pre>
<h2 is-upgraded>Add a sample webview page</h2>
<p>Create a basic HTML file to test rendering your app within the Zoom client.</p>
<h3 is-upgraded>File path: <code>views/webview.html</code></h3>
<pre><code language="language-html" class="language-html">&lt;p&gt;Some text&lt;/p&gt;
&lt;button&gt;Some actions&lt;/button&gt;
</code></pre>
<p>This configuration allows your app to securely launch modal dialogs and render embedded content directly inside the Zoom client‚Äîkey capabilities for building rich, native-feeling chat extensions.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Use Zoom Apps SDK to power modals in Team Chat" duration="0">
        <p>In this section, you&#39;ll configure the Zoom App to surface a custom webview inside Zoom Team Chat using the Zoom Apps SDK. This modal can be launched using app shortcuts and enables direct interaction with users inside the Zoom client‚Äîsuch as composing messages or viewing context.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>A custom webview that runs inside the Zoom Team Chat modal</li>
<li>SDK integration to send messages or display chat context</li>
<li>Secure headers and domain permissions to integrate a third-party app into the Zoom client</li>
</ul>
<h2 is-upgraded>Configure domain allow list</h2>
<p>To enable Zoom to render your app in the Zoom client, you must allowlist the domains used for your webview.</p>
<ol type="1">
<li>Go to the <strong>Surface</strong> tab in your Zoom App configuration</li>
<li>Set the <strong>Home URL</strong> to the path hosting your webview (e.g. <code>https://example.ngrok.app/webview</code>)</li>
<li>Under <strong>Domain Allow List</strong>, add:<ul>
<li><code>ngrok.app</code> ‚Äî required for local development</li>
<li><code>appssdk.zoom.us</code> ‚Äî required to load the Zoom Apps SDK</li>
</ul>
</li>
</ol>
<p>Provide a reason for each custom domain if prompted.</p>
<p><strong>Example UI:</strong></p>
<p class="image-container"><img alt="Domain Allow List Configuration" src="img/a23a1d1392ee9c1.png"></p>
<h2 is-upgraded>Implement Zoom Apps SDK in webview</h2>
<p>Build an HTML view that initializes the Zoom SDK, allows users to compose a message, and optionally view context data from the current chat. This is the modal UI users will interact with inside Zoom.</p>
<p><strong>File path:</strong></p>
<pre><code language="language-bash" class="language-bash">views/webview.html
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code language="language-html" class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&#34;utf-8&#34; /&gt;
    &lt;title&gt;Zoom Workplace Chatbot Demo&lt;/title&gt;

    &lt;!-- ‚úÖ Public script (global zoomSdk) --&gt;
    &lt;script src=&#34;https://appssdk.zoom.us/sdk.min.js&#34; defer&gt;&lt;/script&gt;

    &lt;style&gt;
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 24px;
        max-width: 600px;
        background: #f8f9fa;
      }
      h1 {
        margin-bottom: 20px;
        color: #333;
        text-align: center;
      }
      .demo-container {
        background: white;
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .form-group {
        margin-bottom: 20px;
      }
      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #555;
      }
      textarea {
        width: 100%;
        min-height: 120px;
        padding: 12px;
        border: 2px solid #e1e5e9;
        border-radius: 8px;
        font-family: inherit;
        font-size: 14px;
        resize: vertical;
        box-sizing: border-box;
      }
      textarea:focus {
        outline: none;
        border-color: #0e72ed;
      }
      .button-group {
        display: flex;
        gap: 12px;
        margin-top: 20px;
      }
      button {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }
      .btn-primary {
        background: #0e72ed;
        color: white;
        flex: 1;
      }
      .btn-primary:hover {
        background: #0c5fbb;
      }
      .btn-secondary {
        background: #6c757d;
        color: white;
        flex: 1;
      }
      .btn-secondary:hover {
        background: #545b62;
      }
      .status {
        padding: 12px;
        border-radius: 8px;
        margin-top: 16px;
        text-align: center;
        font-weight: 500;
      }
      .success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f1b0b7;
      }
      .info {
        background: #cce7ff;
        color: #004085;
        border: 1px solid #99d3ff;
      }
      .hint {
        color: #666;
        font-size: 13px;
        margin-top: 8px;
        font-style: italic;
      }
      .context-section {
        background: #f8f9fa;
        padding: 16px;
        border-radius: 8px;
        margin-top: 20px;
        border: 1px solid #e1e5e9;
      }
      .context-title {
        font-weight: 600;
        color: #333;
        margin-bottom: 12px;
        font-size: 16px;
      }
      .context-item {
        background: white;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        border-left: 4px solid #0e72ed;
      }
      .context-item h4 {
        margin: 0 0 8px 0;
        color: #0e72ed;
        font-size: 14px;
      }
      .context-content {
        font-family: &#34;Courier New&#34;, monospace;
        font-size: 12px;
        color: #666;
        background: #f8f9fa;
        padding: 8px;
        border-radius: 4px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .not-in-zoom {
        text-align: center;
        padding: 40px 24px;
        color: #721c24;
        background: #f8d7da;
        border: 1px solid #f1b0b7;
        border-radius: 12px;
        margin: 20px 0;
      }
      .not-in-zoom h2 {
        color: #721c24;
        margin-bottom: 16px;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id=&#34;not-in-zoom-message&#34; class=&#34;not-in-zoom&#34; style=&#34;display: none&#34;&gt;
      &lt;h2&gt;‚ö†Ô∏è Zoom Client Required&lt;/h2&gt;
      &lt;p&gt;
        This page is designed to run inside the Zoom desktop or mobile client.
      &lt;/p&gt;
      &lt;p&gt;
        Please open this URL from within a Zoom chat or meeting to access the
        full functionality.
      &lt;/p&gt;
    &lt;/div&gt;

    &lt;div id=&#34;main-content&#34;&gt;
      &lt;h1&gt;üöÄ Zoom Workplace Chatbot Demo&lt;/h1&gt;

      &lt;div class=&#34;demo-container&#34;&gt;
        &lt;div class=&#34;form-group&#34;&gt;
          &lt;label for=&#34;messageInput&#34;&gt;Custom Message&lt;/label&gt;
          &lt;textarea
            id=&#34;messageInput&#34;
            placeholder=&#34;Type your message here to send to the chat...&#34;
          &gt;&lt;/textarea&gt;
          &lt;div class=&#34;hint&#34;&gt;
            Enter any text you want to send as a message to the current chat
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&#34;button-group&#34;&gt;
          &lt;button id=&#34;sendCustomBtn&#34; class=&#34;btn-primary&#34;&gt;
            Send Custom Message
          &lt;/button&gt;
          &lt;button id=&#34;sendContextBtn&#34; class=&#34;btn-secondary&#34;&gt;
            Send Chat Context
          &lt;/button&gt;
        &lt;/div&gt;

        &lt;div class=&#34;hint&#34; style=&#34;text-align: center; margin-top: 16px&#34;&gt;
          This demo shows how Zoom Apps can interact with chat conversations
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&#34;context-section&#34;&gt;
        &lt;div class=&#34;context-title&#34;&gt;üìä Context Information&lt;/div&gt;
        &lt;div class=&#34;context-item&#34;&gt;
          &lt;h4&gt;Running Context&lt;/h4&gt;
          &lt;div id=&#34;runningContext&#34; class=&#34;context-content&#34;&gt;Not available&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&#34;context-item&#34;&gt;
          &lt;h4&gt;Chat Context&lt;/h4&gt;
          &lt;div id=&#34;chatContext&#34; class=&#34;context-content&#34;&gt;Not available&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div id=&#34;status&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
      /* globals zoomSdk */

      let isInitialized = false;
      let chatContext = null;
      let runningContext = null;

      // Helper to show status messages
      function showStatus(message, type = &#34;info&#34;) {
        const statusDiv = document.getElementById(&#34;status&#34;);
        statusDiv.innerHTML = `&lt;div class=&#34;status ${type}&#34;&gt;${message}&lt;/div&gt;`;
        setTimeout(() =&gt; (statusDiv.innerHTML = &#34;&#34;), 3000);
      }

      // Helper to update context displays
      function updateContextDisplays() {
        const runningContextEl = document.getElementById(&#34;runningContext&#34;);
        const chatContextEl = document.getElementById(&#34;chatContext&#34;);

        if (runningContext) {
          runningContextEl.textContent = JSON.stringify(
            runningContext,
            null,
            2
          );
        }

        if (chatContext) {
          chatContextEl.textContent = JSON.stringify(chatContext, null, 2);
        }
      }

      // Check if running in Zoom client
      function checkZoomEnvironment() {
        if (typeof window.zoomSdk === &#34;undefined&#34;) {
          document.getElementById(&#34;not-in-zoom-message&#34;).style.display =
            &#34;block&#34;;
          document.getElementById(&#34;main-content&#34;).style.display = &#34;none&#34;;
          return false;
        }
        return true;
      }

      // Helper to get signature from your backend
      async function generateSignature(messageString) {
        const res = await fetch(&#34;/api/sign&#34;, {
          method: &#34;POST&#34;,
          headers: { &#34;Content-Type&#34;: &#34;application/json&#34; },
          body: JSON.stringify({ message: messageString }),
        });
        if (!res.ok) throw new Error(&#34;Signature request failed: &#34; + res.status);
        return res.json();
      }

      // Send custom message function
      async function sendCustomMessage() {
        const messageInput = document.getElementById(&#34;messageInput&#34;);
        const message = messageInput.value.trim();

        if (!message) {
          showStatus(&#34;Please enter a message first&#34;, &#34;error&#34;);
          return;
        }

        if (!isInitialized) {
          showStatus(&#34;Zoom SDK not initialized yet&#34;, &#34;error&#34;);
          return;
        }

        try {
          showStatus(&#34;Sending message...&#34;, &#34;info&#34;);

          await zoomSdk.sendMessageToChat({
            message: message,
          });

          showStatus(&#34;‚úÖ Message sent successfully!&#34;, &#34;success&#34;);
          messageInput.value = &#34;&#34;; // Clear the input
          window.close();
        } catch (error) {
          console.error(&#34;Send message error:&#34;, error);
          showStatus(&#34;‚ùå Failed to send message&#34;, &#34;error&#34;);
        }
      }

      // Send chat context function
      async function sendChatContext() {
        if (!isInitialized) {
          showStatus(&#34;Zoom SDK not initialized yet&#34;, &#34;error&#34;);
          return;
        }

        if (!chatContext) {
          showStatus(&#34;No chat context available&#34;, &#34;error&#34;);
          return;
        }

        try {
          showStatus(&#34;Sending chat context...&#34;, &#34;info&#34;);

          const contextMessage = `Chat Context Info:
üìß Chat Type: ${chatContext.chatType || &#34;Unknown&#34;}
üë• Participants: ${chatContext.participants?.length || 0}
üí¨ Content: ${chatContext.content || &#34;No content&#34;}`;

          await zoomSdk.sendMessageToChat({
            message: contextMessage,
          });

          showStatus(&#34;‚úÖ Chat context sent successfully!&#34;, &#34;success&#34;);
          window.close();
        } catch (error) {
          console.error(&#34;Send context error:&#34;, error);
          showStatus(&#34;‚ùå Failed to send chat context&#34;, &#34;error&#34;);
        }
      }

      

      // Initialize the Zoom SDK
      async function init() {
        if (!checkZoomEnvironment()) {
          return;
        }

        try {
          showStatus(&#34;üîÑ Initializing Zoom SDK...&#34;, &#34;info&#34;);

          const capabilities = [
            &#34;getRunningContext&#34;,
            &#34;getChatContext&#34;,
            &#34;sendMessageToChat&#34;,
          ];

          const appInfo = await zoomSdk.config({
            version: &#34;0.16.26&#34;,
            capabilities,
          });

          // Get running context
          runningContext = await zoomSdk.getRunningContext();

          // Get chat context if in chat
          if (appInfo.runningContext === &#34;inChat&#34;) {
            chatContext = await zoomSdk.getChatContext();
            isInitialized = true;
            showStatus(&#34;‚úÖ Ready! You can now send messages.&#34;, &#34;success&#34;);
          } else {
            showStatus(
              &#34;‚ö†Ô∏è This app works best when opened from a chat&#34;,
              &#34;error&#34;
            );
          }

          // Update context displays
          updateContextDisplays();
        } catch (error) {
          console.error(&#34;Initialization failed:&#34;, error);
          showStatus(&#34;‚ùå Failed to initialize Zoom SDK&#34;, &#34;error&#34;);
        }
      }

      // Event listeners
      window.addEventListener(&#34;DOMContentLoaded&#34;, () =&gt; {
        init();

        document
          .getElementById(&#34;sendCustomBtn&#34;)
          .addEventListener(&#34;click&#34;, sendCustomMessage);
        document
          .getElementById(&#34;sendContextBtn&#34;)
          .addEventListener(&#34;click&#34;, sendChatContext);

        // Allow Enter key to send message
        document
          .getElementById(&#34;messageInput&#34;)
          .addEventListener(&#34;keydown&#34;, (e) =&gt; {
            if (e.key === &#34;Enter&#34; &amp;&amp; !e.shiftKey) {
              e.preventDefault();
              sendCustomMessage();
            }
          });
      });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>This setup uses Zoom&#39;s App SDK methods such as <code>sendMessageToChat</code>, <code>getRunningContext</code>, and <code>getChatContext</code> to create a native-feeling experience inside Zoom Team Chat.</p>
<p>The Zoom Apps SDK allows your app to surface interactive modals with full context awareness and message-sending capabilities‚Äîenabling rich, embedded workflows inside Zoom.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Webhook handler" duration="0">
        <h3 is-upgraded>File Path</h3>
<pre><code>routes/zoom-webhookHandler.js
</code></pre>
<h3 is-upgraded>Code Snippet</h3>
<pre><code>Need Code Snippet
</code></pre>
<h2 is-upgraded>Resources</h2>
<ul>
<li><a href="https://developers.zoom.us/docs/team-chat/app-shortcuts-and-apps-sdk/" target="_blank">App shortcuts and Apps SDK</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Add app to Team Chat channel" duration="0">
        <p>In this section, you&#39;ll configure your Zoom chatbot to be added to Team Chat channels, enabling users to activate it on demand. This setup allows your app to listen for channel events, respond to mentions, and participate in threaded conversations across channels.</p>
<p>By the end of this section, you&#39;ll have:</p>
<ul>
<li>Team Chat configuration that supports app invitations to channels</li>
<li>Webhook subscriptions for app-added and removed events</li>
<li>A working channel integration users can trigger directly</li>
</ul>
<h2 is-upgraded>Enable &#34;Add app to channel&#34; in account settings</h2>
<p>To allow users to add your app to chat channels, you must first enable this option in your Zoom account settings.</p>
<ol type="1">
<li>Navigate to the Zoom admin portal</li>
<li>Go to <strong>Account Management &gt; Account Settings &gt; Team Chat</strong></li>
<li>Toggle <strong>&#34;Allow users to add apps to channels&#34;</strong> to enabled</li>
</ol>
<p><strong>Example:</strong></p>
<p class="image-container"><img alt="Enable Add App to Channel Toggle" src="img/4343bfa2bb2f237b.png"></p>
<h2 is-upgraded>Configure app scopes and webhooks</h2>
<p>Ensure your app is configured to support being invited to and removed from channels, and is authorized to listen for related events.</p>
<h3 is-upgraded>Add scopes</h3>
<ol type="1">
<li>In the <strong>Scopes</strong> tab of your app:<ul>
<li>Add: <strong>Enable Chatbot within Zoom Team Chat Channel</strong></li>
</ul>
</li>
</ol>
<h3 is-upgraded>Configure event subscriptions</h3>
<ol type="1">
<li>In the <strong>Access</strong> tab:<ul>
<li>Add the following scopes:<ul>
<li><code>team_chat_channel_chatbot_add</code></li>
<li><code>team_chat_channel_chatbot_removed</code></li>
</ul>
</li>
<li>These events are sent automatically and do not need manual registration:<ul>
<li><code>team_chat.app_invited</code></li>
<li><code>team_chat.app_removed</code></li>
<li><code>team_chat.app_mention</code></li>
<li><code>team_chat.app_conversation_opened</code></li>
</ul>
</li>
</ul>
</li>
<li>Add your webhook endpoint:</li>
</ol>
<pre><code language="language-bash" class="language-bash">https://example.ngrok.app/anthropic
</code></pre>
<h2 is-upgraded>Add the chatbot to a Team Chat channel</h2>
<p>After configuration, add your chatbot to a Zoom Team Chat channel to begin interacting with users.</p>
<ol type="1">
<li>Navigate to a <strong>Team Chat channel</strong></li>
<li>Click the <strong>members icon</strong> at the top of the channel</li>
</ol>
<p><strong>Example:</strong></p>
<p class="image-container"><img alt="Open Add Members Modal" src="img/111f5553763ca043.png"></p>
<ol type="1" start="3">
<li>Under the <strong>Integrations</strong> tab, click <strong>Add apps</strong></li>
</ol>
<p class="image-container"><img alt="Add Apps to Channel" src="img/c75ab6e30475ee88.png"></p>
<ol type="1" start="4">
<li>Search for and select your chatbot app from the list</li>
</ol>
<p class="image-container"><img alt="Search for Chatbot" src="img/c57ccef1e79ad0be.png"></p>
<ol type="1" start="5">
<li>Choose which users/groups can access the app<ul>
<li>Recommended: Select <strong>Users &amp; groups</strong> or <strong>All users</strong></li>
</ul>
</li>
</ol>
<p class="image-container"><img alt="App Permissions Prompt" src="img/4eb4446d9a0785d3.png"></p>
<ol type="1" start="6">
<li>Confirm the app&#39;s permissions and click <strong>Add</strong></li>
</ol>
<p class="image-container"><img alt="Add to Channel Confirmation" src="img/92b4c20f3f1b8908.png"></p>
<p>This setup enables your Zoom chatbot to operate at the channel level‚Äîautomatically listening for interactions and responding to events in a collaborative, multi-user environment.</p>
<h2 is-upgraded>Resources</h2>
<ul>
<li><a href="https://support.zoom.com/hc/en/article?id=zm_kb&sysparm_article=KB0082265" target="_blank">Zoom Support: Using Apps in Chats</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="What&#39;s next" duration="0">
        <p>Explore Zoom Team Chat further by experimenting with richer message layouts, interactive cards, modals, and event-driven workflows. Combine these building blocks with Zoom Apps and Chatbot APIs to design engaging, in-context experiences that meet users where work happens.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
